"""
Universal Binary Principle (UBP) Framework v3.2+ - UBP Cymatic Pattern Analysis Framework
Author: Euan Craig, New Zealand
Date: 03 September 2025
================================================

Analyzing patterns generated by Universal Binary Principle
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Circle, Rectangle
import matplotlib.patches as patches
from matplotlib.collections import LineCollection
import json
from typing import Dict, List, Tuple, Any, Optional
import math
from scipy import signal
from scipy.fft import fft, fftfreq, fft2, fftshift
import pandas as pd

# Import actual UBPConfig for constants
from ubp_config import get_config, UBPConfig

class UBPPatternAnalyzer:
    """
    Advanced analyzer for UBP-generated cymatic patterns
    Focuses on identifying harmonic structures and geometric coherence
    """
    
    def __init__(self, config: Optional[UBPConfig] = None):
        self.config = config if config else get_config() # Ensure config is initialized

        self.constants = {
            'phi': self.config.constants.PHI,  # Golden ratio from config
            'pi': self.config.constants.PI, # Pi from config
            'e': self.config.constants.E,   # e from config
            'harmonic_series': [1.0, 1/2.0, 1/3.0, 1/4.0, 1/5.0, 1/6.0, 1/7.0, 1/8.0] # Ensure floats
        }
        
    def analyze_coherence_pressure(self, pattern_data: np.ndarray) -> Dict[str, Any]:
        """
        Analyze coherence pressure in bitfield patterns
        This is where geometry emerges from frequency relationships
        """
        # Calculate 2D Fourier transform to find frequency components
        fft_2d = fft2(pattern_data)
        magnitude = np.abs(fftshift(fft_2d)) # Use fftshift for centered spectrum
        
        # Find dominant frequencies
        threshold = np.max(magnitude) * 0.1
        peaks_mask = magnitude > threshold # Use a mask
        
        # Calculate coherence metrics
        coherence_score = self._calculate_coherence_score(magnitude) # This is where the problematic value comes from
        harmonic_ratios = self._find_harmonic_ratios(magnitude)
        
        return {
            'coherence_score': float(coherence_score), # Ensured float here
            'dominant_frequencies_coords': self._extract_frequencies(peaks_mask), # Use peaks_mask
            'harmonic_ratios': [float(r) for r in harmonic_ratios],
            'symmetry_score': float(self._calculate_symmetry(magnitude)),
            'pattern_classification': self._classify_pattern(coherence_score, self._extract_geometric_features(pattern_data)) # Added for consistency and classification
        }
    
    def _calculate_coherence_score(self, magnitude: np.ndarray) -> float:
        """
        Calculate how coherent the pattern is based on frequency distribution.
        Ensures harmonic energy is not double-counted by using non-overlapping annuli.
        Excludes the DC component (zero frequency) from total and harmonic energy calculations
        to prevent bias from average signal intensity.
        
        Refinement: Dynamically determine fundamental_radius_unit based on detected peaks
        rather than a fixed fraction of min(h,w).
        """
        h, w = magnitude.shape
        center_y, center_x = h//2, w//2

        # Create a mask to exclude the DC component (center pixel)
        non_dc_mask = np.ones_like(magnitude, dtype=bool)
        non_dc_mask[center_y, center_x] = False
        
        # Calculate total energy of the *non-DC* part of the spectrum
        magnitude_non_dc_values = magnitude[non_dc_mask] 
        total_energy_non_dc = np.sum(magnitude_non_dc_values**2)
        
        if total_energy_non_dc < 1e-15: # Avoid division by near-zero total energy
            return 0.0
            
        combined_harmonic_mask = np.zeros_like(magnitude, dtype=bool)
        
        y_coords, x_coords = np.ogrid[:h, :w]
        dist_from_center = np.sqrt((x_coords - center_x)**2 + (y_coords - center_y)**2)
        
        # Dynamically find the fundamental_radius_unit using peak detection in radial profile
        max_radius = int(min(h, w) // 2) # Safer max_radius
        radial_profile = np.zeros(max_radius)
        if max_radius == 0: # Handle very small patterns
            return 0.0

        for r_idx in range(max_radius):
            mask = (dist_from_center >= r_idx) & (dist_from_center < r_idx + 1)
            radial_profile[r_idx] = np.sum(magnitude[mask & non_dc_mask]) # Only sum non-DC magnitudes

        # Exclude very low frequencies (near DC) from peak search
        min_peak_distance = max(1, int(max_radius / 10)) # Ensure minimum distance between peaks
        peaks, properties = signal.find_peaks(radial_profile, height=np.max(radial_profile) * 0.1, distance=min_peak_distance)
        
        fundamental_radius_unit = 0
        if len(peaks) > 0:
            # Use the first significant peak as the fundamental
            fundamental_radius_unit = peaks[0]
        else:
            # Fallback if no clear peaks detected, use a sensible default
            fundamental_radius_unit = max_radius / 10 if max_radius > 0 else 1 # Adjusted fallback for robustness
        
        # Ensure fundamental_radius_unit is a positive integer
        fundamental_radius_unit = max(1, int(fundamental_radius_unit))

        # Generate harmonic radii based on the dynamically determined fundamental
        harmonic_ratios_filtered = [ratio for ratio in self.constants['harmonic_series'] if ratio > 1e-9] 
        # Only consider integer multiples for fundamental coherence score for now, as subharmonics might be noise
        relevant_harmonic_radii = sorted([int(r * fundamental_radius_unit) for r in harmonic_ratios_filtered if r * fundamental_radius_unit > 0.5]) # Filter for integer-like radii
        
        band_width = 3 # pixels
        
        for radius in relevant_harmonic_radii:
            inner_radius = max(0, radius - band_width)
            outer_radius = min(min(h, w) // 2, radius + band_width) 
            
            if inner_radius < outer_radius:
                annulus_mask = (dist_from_center >= inner_radius) & (dist_from_center < outer_radius)
                combined_harmonic_mask = combined_harmonic_mask | annulus_mask
        
        harmonic_energy_non_dc = np.sum(magnitude[combined_harmonic_mask & non_dc_mask]**2) # AND with non_dc_mask
        
        raw_coherence_score = harmonic_energy_non_dc / total_energy_non_dc if total_energy_non_dc > 0 else 0.0
        
        coherence_score_clipped = float(np.clip(raw_coherence_score, 0.0, 1.0))
        return coherence_score_clipped
    
    def _find_harmonic_ratios(self, magnitude: np.ndarray) -> List[float]:
        """Identify frequency ratios that correspond to harmonic relationships"""
        h, w = magnitude.shape
        center_y, center_x = h//2, w//2
        
        y, x = np.ogrid[:h, :w]
        dist_from_center = np.sqrt((x - center_x)**2 + (y - center_y)**2)
        
        max_radius = int(min(h, w) // 2)
        if max_radius == 0: # Handle very small patterns
            return []
            
        radial_profile = np.zeros(max_radius)
        
        non_dc_mask = np.ones_like(magnitude, dtype=bool)
        non_dc_mask[center_y, center_x] = False # Exclude DC for radial profile calc

        for r_idx in range(max_radius):
            mask = (dist_from_center >= r_idx) & (dist_from_center < r_idx + 1)
            radial_profile[r_idx] = np.sum(magnitude[mask & non_dc_mask]) # Only sum non-DC magnitudes
        
        min_peak_distance = max(1, int(max_radius / 10))
        peaks_found, properties = signal.find_peaks(radial_profile, height=np.max(radial_profile) * 0.1, distance=min_peak_distance)
        
        ratios = []
        if len(peaks_found) > 1 and peaks_found[0] > 0: # Ensure fundamental peak is non-zero
            for i in range(1, len(peaks_found)):
                ratio = peaks_found[i] / peaks_found[0]
                ratios.append(float(ratio))
        
        return ratios
    
    def _create_circular_mask(self, h: int, w: int, center_y: int, center_x: int, radius: int) -> np.ndarray:
        """Create a circular mask for frequency analysis"""
        y, x = np.ogrid[:h, :w]
        mask = (x - center_x)**2 + (y - center_y)**2 <= radius**2
        return mask
    
    def _calculate_symmetry(self, magnitude: np.ndarray) -> float:
        """Calculate symmetry score of the frequency distribution"""
        h, w = magnitude.shape
        
        # Ensure arrays are valid for correlation
        if h < 2 or w < 2:
            return 0.0 # Cannot calculate symmetry for small arrays

        # Horizontal symmetry
        if h//2 > 0:
            h_sym_val = np.corrcoef(magnitude[:h//2, :].flatten(), 
                                     np.flip(magnitude[h//2:, :], 0).flatten())[0, 1]
            horizontal_sym = float(h_sym_val) if not np.isnan(h_sym_val) else 0.0
        else: horizontal_sym = 0.0

        # Vertical symmetry
        if w//2 > 0:
            v_sym_val = np.corrcoef(magnitude[:, :w//2].flatten(), 
                                   np.flip(magnitude[:, w//2:], 1).flatten())[0, 1]
            vertical_sym = float(v_sym_val) if not np.isnan(v_sym_val) else 0.0
        else: vertical_sym = 0.0
        
        # Diagonal symmetry - handle non-square arrays by cropping
        min_dim = min(h, w)
        pattern_cropped = magnitude[:min_dim, :min_dim]
        d_sym_val = np.corrcoef(pattern_cropped.flatten(), 
                                   np.flip(pattern_cropped.T, (0, 1)).flatten())[0, 1]
        diagonal_sym = float(d_sym_val) if not np.isnan(d_sym_val) else 0.0
        
        return np.mean([horizontal_sym, vertical_sym, diagonal_sym])
    
    def _extract_frequencies(self, peaks_mask: np.ndarray) -> List[Tuple[int, int]]:
        """Extract dominant frequencies from peaks mask as (row, col) coordinates."""
        # np.where returns (array_of_y_coords, array_of_x_coords)
        y_coords, x_coords = np.where(peaks_mask)
        # Combine them into a list of (x, y) tuples
        return [(int(x), int(y)) for x, y in zip(x_coords, y_coords)]

    def _extract_geometric_features(self, pattern: np.ndarray) -> Dict[str, Any]:
        """
        Extract geometric features from patterns (simplified for general use).
        This version is less prone to errors with diverse pattern inputs.
        """
        from scipy.ndimage import label
        
        # Threshold for shape detection (dynamic based on pattern mean and std dev)
        # Using a safer threshold: mean - 0.5 * std_dev to capture more features reliably
        mean_val = np.mean(pattern)
        std_val = np.std(pattern)
        if std_val < 1e-9: # Handle flat patterns
            threshold = mean_val
        else:
            threshold = mean_val - 0.5 * std_val # Adjust threshold
        
        binary_pattern = (pattern > threshold).astype(int)
        
        # Label connected components
        labeled, num_features = label(binary_pattern) # Using original binary pattern directly to avoid issues with erosion on small patterns
        
        features = {
            'num_shapes': num_features,
            'total_area': np.sum(binary_pattern),
        }
        return features

    def _classify_pattern(self, coherence_score: float, geometric_features: Dict[str, Any]) -> str:
        """Classify pattern based on coherence and geometry"""
        num_shapes = geometric_features.get('num_shapes', 0)
        
        if coherence_score > self.config.performance.COHERENCE_THRESHOLD * 0.9: # Using a scaled config threshold
            if num_shapes == 1:
                return "Perfect Coherence - Single Dominant Form"
            elif num_shapes <= 3:
                return "High Coherence - Crystalline Structure"
            else:
                return "High Coherence - Complex Harmony"
        elif coherence_score > self.config.performance.COHERENCE_THRESHOLD * 0.6:
            if num_shapes <= 5:
                return "Medium Coherence - Ordered Complexity"
            else:
                return "Medium Coherence - Chaonic Structure"
        elif coherence_score > self.config.performance.COHERENCE_THRESHOLD * 0.3:
            return "Low Coherence - Transitional Pattern"
        else:
            return "Minimal Coherence - Random Distribution"
    
    def generate_harmonic_test_patterns(self, size: int = 256) -> Dict[str, np.ndarray]:
        """Generate test patterns to validate harmonic relationships"""
        
        patterns = {
            'fundamental': self._create_harmonic_pattern(size, [1]),
            'second_harmonic': self._create_harmonic_pattern(size, [1, 2]),
            'golden_ratio': self._create_golden_ratio_pattern(size),
            'phi_harmonics': self._create_phi_harmonic_pattern(size)
        }
        
        return patterns
    
    def _create_harmonic_pattern(self, size: int, harmonics: List[float]) -> np.ndarray:
        """Create a pattern based on harmonic frequencies"""
        x = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        y = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        X, Y = np.meshgrid(x, y)
        
        pattern = np.zeros_like(X)
        for h in harmonics:
            pattern += np.sin(h * X) * np.sin(h * Y)
        
        # Normalize to 0-1 range
        if pattern.max() - pattern.min() > 1e-9:
            pattern = (pattern - pattern.min()) / (pattern.max() - pattern.min())
        else:
            pattern = np.zeros_like(pattern)
        return pattern
    
    def _create_golden_ratio_pattern(self, size: int) -> np.ndarray:
        """Create pattern based on golden ratio relationships"""
        x = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        y = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        X, Y = np.meshgrid(x, y)
        
        phi = self.constants['phi']
        pattern = np.sin(X) * np.sin(phi * Y) + np.sin(phi * X) * np.sin(Y)
        
        # Normalize to 0-1 range
        if pattern.max() - pattern.min() > 1e-9:
            pattern = (pattern - pattern.min()) / (pattern.max() - pattern.min())
        else:
            pattern = np.zeros_like(pattern)
        return pattern
    
    def _create_phi_harmonic_pattern(self, size: int) -> np.ndarray:
        """Create pattern using phi-based harmonics"""
        x = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        y = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        X, Y = np.meshgrid(x, y)
        
        phi = self.constants['phi']
        harmonics = [1, phi, phi**2, phi**3]
        
        pattern = np.zeros_like(X)
        for h in harmonics:
            pattern += np.sin(h * X) * np.cos(h * Y)
        
        # Normalize to 0-1 range
        if pattern.max() - pattern.min() > 1e-9:
            pattern = (pattern - pattern.min()) / (pattern.max() - pattern.min())
        else:
            pattern = np.zeros_like(pattern)
        return pattern
    
    def analyze_constants_as_patterns(self, constants: List[float], size: int = 128) -> Dict[str, Any]:
        """Analyze mathematical constants as potential cymatic patterns"""
        results = {}
        
        for const in constants:
            # Create pattern based on constant
            pattern = self._constant_to_pattern(const, size)
            
            # Analyze coherence
            analysis = self.analyze_coherence_pressure(pattern)
            
            results[str(const)] = {
                'pattern_data_array': pattern.tolist(), # Store as list for JSON
                'analysis': analysis,
                'harmonic_fitness': float(self._calculate_harmonic_fitness(const, analysis))
            }
        
        return results
    
    def _constant_to_pattern(self, constant: float, size: int) -> np.ndarray:
        """Convert a constant value into a cymatic-like pattern"""
        x = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        y = np.linspace(-self.constants['pi'], self.constants['pi'], size)
        X, Y = np.meshgrid(x, y)
        
        # Use constant as frequency multiplier
        pattern = np.sin(constant * X) * np.sin(constant * Y)
        
        # Normalize to 0-1 range
        if pattern.max() - pattern.min() > 1e-9:
            pattern = (pattern - pattern.min()) / (pattern.max() - pattern.min())
        else:
            pattern = np.zeros_like(pattern)
        return pattern
    
    def _calculate_harmonic_fitness(self, constant: float, analysis: Dict[str, Any]) -> float:
        """Calculate how well a constant fits harmonic patterns"""
        coherence = analysis['coherence_score']
        harmonic_ratios = analysis['harmonic_ratios']
        
        # Check if ratios are close to simple fractions (harmonics)
        simple_fractions = [0.5, 1/3, 2/3, 1/4, 3/4, 1/5, 2/5, 3/5, 4/5]
        
        fitness = 0
        for ratio in harmonic_ratios:
            for frac in simple_fractions:
                if abs(ratio - frac) < 0.1:
                    fitness += 1
        
        return coherence * (1 + fitness / max(len(harmonic_ratios), 1))